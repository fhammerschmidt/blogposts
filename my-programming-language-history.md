Nowadays, it is certainly more the norm to be a polyglot programmer than to be lucky enough to only need one main programming language. I am no different. I stumbled over a lot of both popular and unpopular programming languages over the course of my life.

My first one was something with moving turtles. Probably **Logo** or some more modern take on turtle graphics, I don't know. However I was too young at that time to even understand what I am doing, but I liked to make the turtle move. Not sure if that experiences formed my brain to dive deeper into all things computers later on.

My second one was **HTML**. Yes, it's just a markup language, but I still created _something_ just by writing text into an editor. Also it felt more useful to me than the Logo turtles which felt more like a game to me.

As a teenager, I stumbled over Ubuntu and started a bit of **Bash** scripting. This was when I really got to know the power of programming, because I could just pipe the output of one program to the next one and would only need to combine them to create something I was not even aware I could do. I mainly used it to organize my music collection - streaming services were not a thing back then.

Later I started a job in a huge company where I mostly formatted Word documents or extended huge Excel sheets. Of course I got into **VBA** at that time, which I learned quickly, is both boon and bane. Some excel sheets really evolved into unmaintainable behemoths, unfortunately.

But it started to really diversify when I went to university. I started studying electrical engineering, where programming is an important part. Naturally, you learn **C** there, which I both liked and hated. I eventually switched to information systems, not because programming in C was too hard, but the physics and electrical engineering classes were just a chore for me I could not really stand.

In information systems, **Java** was the bees knees. I learned it, did the necessary exams and classes but still hated it, because I found it too verbose. OOP was no problem for me, though. But using a full-fledged IDE for a project was very overwhelming at first.

Another class was based around "semistructured data", which was where I learned not only how to write well-formed **XML** but also **XSLT**. It's really powerful but also yet another markup language so of course it does not count (or does it?).

Next up I had a relational databases class FROM WHERE I found the theory pretty useful, but I would SELECT **SQL** as the most useful skill I took out of this class. Also one of the professors contributed to the SQL-99 standard back then, which made me automatically pay attention a bit more.

There is always the class where you get to decide what language you use for a project, so naturally our team decided to go with **Python**. Django was still a young technology, but the project incorporated HTML, CSS and SQL as well, so it fostered my knowledge.

Of course, some professors prefer pretty weird languages, and in another class I got to know **ooRexx**, which is an object-oriented extension to IBMs Rexx language which itself is said to be a programming language for humans rather than computers. And it is really true in some ways. Everything is a string, and hello world is just "SAY Hello World" (without the quotes). We scripted office applications with it which felt much nicer than VBA. Later, we also scripted Java apps with it, which felt somewhat weird, since for most things it was easier to write things in Java, which is a much more googleable language than ooRexx.

Fast-forward to my masters degree, which was when the machine learning hype started to gain traction. So I had a class where we used **R**. It's a language that specializes in statistical computing. I found it really nice, especially that it was so easy to create nice plots without using MS Excel.

The masters was also the time when I created my first web app with **PHP**, **JavaScript** and GeoServer. I had not really a clue what I was doing, but it worked pretty well regardless.

Then I took the most technical specialization the degree offered. The first class of it already made us compare the OOP capabilities of JavaScript, **Ruby**, and **XOTcl**. Yes the last one is an object-oriented extension to [Tcl](https://www.tcl.tk/) (the tool command language) which is a pretty esoteric language in itself. Eventually, we got to know this language a bit more in a later class where I made a little forum app with an upvote/downvote system.

We also had an IOT class where I was introduced to Arduino which you basically write in **C++**. Still, I resorted to doing the final project with a Raspberry Pi, a Bluetooth low energy module and a bunch of bash scripts. It was good enough for a working prototype (and it got me an A).

Meanwhile, before the end of my studies, I got a freelancer job as a real software developer. I needed to write a complex signup form with Ruby on Rails. That job was a great reference to land a real job which I did.

There, I was not only introduced to React, I also learned to write modern JavaScript (with flowtype at that time). Because of React-Native, I also needed to write the occasional Java or **Objective-C**. Or now **Kotlin** and **Swift**.

We saw that **TypeScript** is probably the better horse to bet on, so we ditched flow for most existing projects in favor of TS. However, also ReasonML/BuckleScript emerged at that time, which was really a good fit for the mission-critical apps we were building. And now I am involved in developing tools for it, or rather its successor, **ReScript**.

But wait, it does not stop there. Having learned a Meta-Language-like language like ReScript makes it really easy to get into **OCaml** which behaves similarly. Just for fun I also read two **Rust** books and tinkered with that language as well. The jump to Rust is not that far-fetched from an ML-descendant.

In the end I count 22 languages:

- [Bash](https://www.gnu.org/software/bash/)
- [C](https://www.open-std.org/jtc1/sc22/wg14/)/[C++](https://www.open-std.org/jtc1/sc22/wg21/)
- [HTML](https://html.spec.whatwg.org/)
- [Java](https://www.java.com/en/)
- [JavaScript](https://tc39.es/ecma262/)
- [Kotlin](https://kotlinlang.org/)
- Logo (again, not sure about that)
- [Objective-C](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html)
- [OCaml](https://ocaml.org/)
- [ooRexx](https://www.oorexx.org/about.html)
- [PHP](https://www.php.net/)
- [Python](https://www.python.org/)
- [R](https://www.r-project.org/)
- [ReScript](https://rescript-lang.org/) (previously BuckleScript + ReasonML)
- [Ruby](https://www.ruby-lang.org/en/)
- [Rust](https://www.rust-lang.org/)
- [SQL](https://www.postgresql.org/)
- [Swift](https://www.swift.org/)
- [TypeScript](https://www.typescriptlang.org/)
- VBA
- [XML](https://www.w3.org/XML/)/[XSLT](https://www.w3.org/TR/xslt-30/)
- [XOTcl](http://media.wu.ac.at/) and its successor, the [next scripting framework](https://next-scripting.org/xowiki/about)

and that does not even include the languages I did not even learn properly, but just by using it, for instance because they come with the tooling environment, like Groovy, YAML, and so on. Also not the languages I just tinkered with a bit, like Go or Elm.

How many languages did you already use for more than just writing "Hello, world"? Did you get to know some really weird ones? Tell me about it in the comments!

Thank you for reading, hope you enjoy this slightly different blog post from me. The next one will be focused at ReScript again, I promise.

(cover image generated with [craiyon.com](https://www.craiyon.com/))
